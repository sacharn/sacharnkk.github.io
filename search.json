[{"title":"开发者边车解谜小游戏","url":"https://sacharn.github.io/2021/08/20/开发者边车解谜小游戏/","content":"加密人说他把谜面留在源码的//TODO中。\n打开源码，找到他留下的谜面如下：\n\\u0061\\u0048\\u0052\\u0030\\u0063\\u0044\\u006f\\u0076\\u004c\\u0032\\u0052\\u006c\\u0064\\u0069\\u0031\\u007a\\u0061\\u0057\\u0052\\u006c\\u0059\\u0032\\u0046\\u0079\\u004c\\u006d\\u0052\\u0076\\u0059\\u0032\\u0031\\u0070\\u0063\\u006e\\u004a\\u0076\\u0063\\u0069\\u0035\\u006a\\u0062\\u0069\\u0039\\u0035\\u0062\\u0033\\u0056\\u006d\\u0061\\u0057\\u0035\\u006b\\u0061\\u0058\\u0051\\u0076\\u0061\\u0057\\u0035\\u006b\\u005a\\u0058\\u0067\\u0075\\u0061\\u0048\\u0052\\u0074\\u0062\\u0041\\u003d\\u003d\n\n\n\n于是，以下是我的解密之路：\n发现这是Unicode，用IDEA先调一个Unicode转String的方法，解谜一层\n转换方法是\npublic static void main(String[] args) &#123;        String a = &quot;\\\\u0061\\\\u0048\\\\u0052\\\\u0030\\\\u0063\\\\u0044\\\\u006f\\\\u0076\\\\u004c\\\\u0032\\\\u0052\\\\u006c\\\\u0064\\\\u0069\\\\u0031\\\\u007a\\\\u0061\\\\u0057\\\\u0052\\\\u006c\\\\u0059\\\\u0032\\\\u0046\\\\u0079\\\\u004c\\\\u006d\\\\u0052\\\\u0076\\\\u0059\\\\u0032\\\\u0031\\\\u0070\\\\u0063\\\\u006e\\\\u004a\\\\u0076\\\\u0063\\\\u0069\\\\u0035\\\\u006a\\\\u0062\\\\u0069\\\\u0039\\\\u0035\\\\u0062\\\\u0033\\\\u0056\\\\u006d\\\\u0061\\\\u0057\\\\u0035\\\\u006b\\\\u0061\\\\u0058\\\\u0051\\\\u0076\\\\u0061\\\\u0057\\\\u0035\\\\u006b\\\\u005a\\\\u0058\\\\u0067\\\\u0075\\\\u0061\\\\u0048\\\\u0052\\\\u0074\\\\u0062\\\\u0041\\\\u003d\\\\u003d&quot;;        String s = unicode2String(a);        System.out.println(s);    &#125;    public static String unicode2String(String unicode) &#123;        StringBuffer string = new StringBuffer();        String[] hex = unicode.split(&quot;\\\\\\\\u&quot;);        for (int i = 1; i &lt; hex.length; i++) &#123;            // 转换出每一个代码点            int data = Integer.parseInt(hex[i], 16);            // 追加成string            string.append((char) data);        &#125;        return string.toString();    &#125;\n\n点击“运行”，运行结果为：\naHR0cDovL2Rldi1zaWRlY2FyLmRvY21pcnJvci5jbi95b3VmaW5kaXQvaW5kZXguaHRtbA&#x3D;&#x3D;\n\n发现这又是一个编码后的串，需要再解密\n因为是==结尾，所以这是一个base64的加密方式\n于是，直接上网查base64解码，解码得\nhttp:&#x2F;&#x2F;dev-sidecar.docmirror.cn&#x2F;youfindit&#x2F;index.html\n\n接下来就是，登录这个网站，我以为结束了，毫不费力嘛~\n打开网站傻眼了，却发现除了文字之外，啥也没有…\n\n嗐，这又是开发者留下的有一个谜，于是继续探寻…\n既然页面看不出什么名堂，就直接进入开发者模式\n看看有没有什么隐藏的内容，是加密人藏在里面的！\n\n果不其然啊，他偷偷藏了一个图片在页面里，看不见（我也是醉了），于是我直接把图片下下来，发现是个二维码，但是这个二维码是透明的，这也就是为什么能够藏在页面里，不被看到的原因。这个二维码的信息显示，它也是base64加密的，于是顺手解密看看，发现他是用photoshop处理的这个透明。不过这对解密没啥大用。\n这个透明的二维码，用微信是扫不出来的。于是陷入迷茫，我也不会ps，咋搞？\n灵机一动，我直接用图片查看器打开，然后用截图工具截图，再传到微信扫一扫\n终于谜底出现了…\n\n","categories":[],"tags":[]},{"title":"畅想夏日","url":"https://sacharn.github.io/2021/05/21/畅想夏日/","content":"盛夏，太阳把灼热的强光照射在大地上，蝉声就像白噪声一样持续不断，心情烦躁时听了愈加烦躁，但是午休时又能伴着规律的蝉声入眠，能睡得更香更沉。猫狗和人都害怕暴晒，所以都躲到阴凉中，困倦。只有绿色的植物显得更加精神和具有生气，明澈的河水也比往常更显得透亮与清凉。夏天的果蔬是最受人喜爱的，我们会在院子里自己种上一些果蔬，按照时令季节种植与采摘。我们用剪刀剪下一颗在阳光下把红到熟透的番茄，赞叹一下它的丰腴，也感恩这一季的风调雨顺，然后将其洗净，用细长的水果刀将其等分成八块，争取每一块中间都保留着完整的瓤，好让它晶莹的橙色看着就让人觉得酸溜溜的，不至于流的满切板都是。这时，拿一只洁白的果盘，把切好的番茄块整齐摆好，最后撒上一勺白糖，这就是独属于夏天的一份酸酸甜甜啦。\n到了夏天，就不能少了我最爱吃的西瓜。西瓜，脆瓤的还是沙瓤的，我都喜欢，到底还是更喜欢脆瓤的，但是不管是哪种瓤，总归要冰镇一下的。冰镇西瓜也不麻烦，这是用不着冰箱的，我们有自己的好办法，只要从庭院里的水井中打上一桶冬暖夏凉的井水，然后将西瓜放入其中，一点不耽搁干别的事，过个把小时来取即可。要吃到好的西瓜，首先得学会选西瓜。选西瓜简直就是在赌石，都要仔细看纹路，检查一下蒂是否发枯，最经典的莫过于用手拍两下看看熟不熟，至于什么声音属于熟了，我到现在也没搞清楚。最紧张也最期待的莫过于开瓜的时刻，如果是一刀下去，瓜自己就开了，那么这就是最好的瓜，它就像一个成绩很好但是骄傲的学生，一点都不含蓄，淋漓尽致的展示了自己的优秀。当一颗西瓜一分为二，敞开肚皮对着我的时候，也是我幸福的烦恼开始的时刻，以前我会纠结于是用勺子挖着吃还是分块吃。现在我不会再有这样的烦恼了，因为一个人的话就可以在空调房里，一边看着综艺，不紧不慢的挖着吃，吃满足了就放在一旁，等会再吃，两个人或者多个人的话，那就切着吃，因为说笑间吃得会更有滋味，也更热闹些。\n炽热的大太阳也不都是一无是处，阳光会让时光加速，阴雨要一天才能风干的衣服在盛夏晴天下仅仅需要三两个小时，当微风浮动衣物时，它们已经是吸满了阳光的味道。阳光还会与黄豆一起，在时间的催化下，酝酿出奶奶的黄豆酱，我从小见到的就是每年夏天放置在庭院中的酱缸。酱缸是中等体积的瓦缸，里面最初放入的是洗净的黄豆，中间还有一些工序我不知道，最后再以绿纱网封口，原谅我吧，夏天小男孩只会对游泳感兴趣，哪里会主动去了解这些事情呢。酱缸最害怕的就是阵雨，一场阵雨就能让前面的努力都化为乌有。所以，只要天色有变，就要紧急转移，保我方酱缸无虞。阳光会携带热量将水升温，这就是太阳能工作的基本原理。我们不用买太阳能，只要学习老辈人的智慧，将一个装满水的塑料桶上铺上一层塑料膜，盛夏的太阳发挥了一天的威力，傍晚时分水已经十分温热了，这时候我们用它冲一个澡。我通常喜欢最后留小半桶水，将桶举过头顶，突然倒扣，将水从头淋到脚，那是非常刺激的。\n夏天的花是开的很盛的，我们要在院子里种上繁茂的花，花的颜色我要选粉红色的，纯白色的，不要一些艳俗的色彩，例如紫红色等。到时候花开的纷纷洋洋，一团一簇的，微风混合着各色花香，在夏天的气息里荡漾。我们不能偷懒，要时常修剪，以便能够节省养分，也为了美观。当用剪刀剪动花枝，一些花就忍不住随风散开了，下一场花雨，这是我们的粗鲁，却是她的浪漫。我不打算让散落的花瓣零落成泥碾作尘，我们还要靠她来堆肥呢。院子里的墙要刷成白色，再嵌入一个天蓝色的木窗。运气好的话，在晴空万里的天气，会有飞机在蔚蓝色的天空画上一道白色的尾迹。到时候我要搬出藤椅，加一杯茶，要是心情不错，就捧一本书，饶有兴致的看起来，累了就看看天，看看飞机，看看花，看看院墙和木窗，闻一闻茶香，闻一闻花香，也闻一闻书香。风一吹，可能就躺着睡着了，这就度过了一个闲适的下午。\n屋檐伸出来的部分，铺上一层黄色的衰草，供雨水往下流淌，卧室的窗边的外面就种植芭蕉，雨天的晚上就能听那雨打芭蕉的声音了，这时候可以想自己的事，也可以畅想一下宋代的词人在听雨打芭蕉声的时候在思考些什么。\n待续…\n","categories":[],"tags":[]},{"title":"登录接口安全注意事项","url":"https://sacharn.github.io/2021/04/27/登录接口安全注意事项/","content":"登录接口安全问题一 暴力破解只要网站是暴露在公网的，那么很大概率上会被人盯上，尝试爆破这种简单且有效的方式：通过各种方式获得了网站的用户名之后，通过编写程序来遍历所有可能的密码，直至找到正确的密码为止\n解决方案\n① 验证码校验\n我可以在它密码错误达到一定次数时，增加验证码校验！比如我们设置，当用户密码错误达到3次之后，则需要用户输入图片验证码才可以继续登录操作\n缺陷：这样确实可以过滤掉一些非法的攻击，但是以目前的OCR技术来说的话，普通的图片验证码真的很难做到有效的防止机器人。\n当然，我们也可以花钱购买类似于三方公司提供的滑动验证等验证方案，但是也并不是100%的安全，一样可以被破解\n②登录限制\n那这时候又有同学说了，那我可以直接限制非正常用户的登录操作，当它密码错误达到一定次数时，直接拒绝用户的登录，隔一段时间再恢复。比如我们设置某个账号在登录时错误次数达到10次时，则5分钟内拒绝该账号的所有登录操作。\n缺陷：这样确实可以解决用户密码被爆破的问题。但是，这样会带来另一个风险：攻击者虽然不能获取到网站的用户信息，但是它可以让我们网站所有的用户都无法登录！\n攻击者只需要无限循环遍历所有的用户名（即使没有，随机也行）进行登录，那么这些用户会永远处于锁定状态，导致正常的用户无法登录网站！\n③IP限制\n既然直接针对用户名不行的话，我们可以针对IP来处理，直接把攻击者的IP封了不就万事大吉了嘛。我们可以设定某个IP下调用登录接口错误次数达到一定时，则禁止该IP进行登录操作。\n缺陷：现在很多学校、公司都是使用同一个出口IP，如果直接按IP限制，可能会误杀其它正常的用户。攻击者完全可以在IP被封后切换VPN来攻击\n④手机验证\n几乎所有的应用都会让用户绑定手机，一个是国家的实名制政策要求，第二个是手机基本上和身份证一样，基本上可以代表一个人的身份标识了。所以很多安全操作都是基于手机验证来进行的，登录也可以。\n\n当用户输入密码次数大于3次时，要求用户输入验证码（最好使用滑动验证）\n当用户输入密码次数大于10次时，弹出手机验证，需要用户使用手机验证码和密码双重认证进行登录\n\n我们结合了上面说的几种方式的同时，加上了手机验证码的验证模式，基本上可以阻止相当多的一部分恶意攻击者。但是没有系统是绝对安全的，我们只能够尽可能的增加攻击者的攻击成本。大家可以根据自己网站的实际情况来选择合适的策略。\n问题二 中间人攻击什么是中间人攻击**中间人攻击(man-in-the-middle attack, abbreviated to MITM)**，简单一点来说就是，A和B在通讯过程中，攻击者通过嗅探、拦截等方式获取或修改A和B的通讯内容。\n举个栗子：小白给小黄发快递，途中要经过快递点A，小黑就躲在快递点A，或者干脆自己开一个快递点B来冒充快递点A。然后偷偷的拆了小白给小黄的快递，看看里面有啥东西。甚至可以把小白的快递给留下来，自己再打包一个一毛一样的箱子发给小黄。\n那在登录过程中，如果攻击者在嗅探到了从客户端发往服务端的登录请求，就可以很轻易的获取到用户的用户名和密码。\nHTTPS防范中间人攻击最简单也是最有效的一个操作，更换HTTPS，把网站中所有的HTTP请求修改为强制使用HTTPS。\n为什么HTTPS可以防范中间人攻击？HTTPS实际上就是在HTTP和TCP协议中间加入了SSL/TLS协议，用于保障数据的安全传输。相比于HTTP，HTTPS主要有以下几个特点：\n\n内容加密\n数据完整性\n身份验证\n\n\n具体的HTTPS原理这里就不再扩展了，大家可以自行Google\n\n加密传输在HTTPS之外，我们还可以手动对敏感数据进行加密传输：\n\n用户名可以在客户端使用非对称加密，在服务端解密\n密码可以在客户端进行MD5之后传输，防止暴露密码明文\n\n其它问题除了上面我们聊的这些以外，其实还有很多其它的工作可以考虑，比如：\n\n操作日志，用户的每次登录和敏感操作都需要记录日志（包括IP、设备等）\n\n异常操作或登录提醒，有了上面的操作日志，那我们就可以基于日志做风险提醒，比如用户在进行非常登录地登录、修改密码、登录异常时，可以短信提醒用户\n\n拒绝弱密码 注册或修改密码时，不允许用户设置弱密码\n\n防止用户名被遍历 有些网站在注册时，在输入完用户名之后，会提示用户名是否存在。这样会存在网站的所有用户名被泄露的风险（遍历该接口即可），需要在交互或逻辑上做限制\n\nMD5现在已经不是⼗分安全了，最好使sha256，sha512之类安全强度更⾼的散列加密算法。\n\n⽤户名密码错误不要单⽅⾯提⽰，如果密码错误提⽰⽤户说密码错误这样攻击者就知道⽤户名是对的，下次攻击密码，所以不管是⽤户名还是密码错误都给出同样的提⽰：用户名或密码错误，或者别的不具体的提⽰的错误都可以。\n\n 前端禁⽌⽤户输⼊导致sql注⼊的字符，后台也要做sql注⼊的防护。\n\n不要在cookie中保留⽤户密码，如果⼀定要使⽤cookie实现⾃动登录，切记不要使⽤简单的⽤户名＋密码MD5保存到cookie，要把⽤户ID、⽤户名、过期时间、IP、不固定的salt等⼀起考虑进去，这个当然要可逆，服务端要进⾏解密才能验证⽤户⾃动登录有效。另外，cookie要设置为http only,这样就不能通过脚本访问cookie，保证cookie的安全性。\n\n有必要的要采⽤单点登陆，如果允许⽤户多处登录的要给⽤户安全提醒。\n\n可以考虑使⽤第三方授权登录接⼝，如qq登录，微信登录，微博登录，github登录等等，优化⽤户登录体验。\n\n\n","categories":[],"tags":[]},{"title":"科研进展","url":"https://sacharn.github.io/2021/04/26/科研进展/","content":"FDA+IRS+BeamForming实现保密通信\n\n\n\n","categories":[],"tags":[]},{"title":"HashMap底层原理","url":"https://sacharn.github.io/2021/04/22/HashMap底层原理/","content":"HashMaphashMap的默认容量是16，默认扩容因子是0.75，这是综合了空间和时间两个方面考虑的。扩容因子太小，hashMap就会经常扩容，扩容因子太大，就会导致hash冲突现象严重。\nhashMap的底层是数组加链表(JDK1.8后改为数组加链表/红黑树，一个hash桶的元素大于8并且hashMap的容量大于等于64时，使用红黑树结构，如果桶的元素变为6，就重新变为链表，为什么是6，是为了防止红黑树和链表来回转换)经过计算，在hash函数设计合理的情况下，发生hash碰撞8次的几率为百万分之6，8就够用了。\n这里hash值的计算hashMap重新定义了，JDK1.7的算法比较复杂，JDK1.8是让hashcode的前16位与后16位进行亦或计算，目的是为了让hash的取值平均一点，不要让太多的对象放在同一个hash桶中。为什么这样设计：\n一定要尽可能降低hash碰撞，越分散越好；降低的原因：如果hashcode的散列做的不好，导致hashcode的后面几位很容易出现相同，出现hash碰撞现象，重新计算hash值可以减少这个问题的发生。\n算法一定要尽可能高效，因为这是高频操作, 因此采用位运算；\n计算桶的位置，是用hash值与hashMap的容量减一进行与运算。\nhashMap的默认容量是16，也可以自己设置，但是必须是2的n次方，如果不是，则向上取为2的n次方，如设置容量为10，则实际容量为16.\n\nJDK1.8hashMap的优化：\n\\1.    数组+链表改成了数组+链表或红黑树；\n\\2.    链表的插入方式从头插法改成了尾插法，简单说就是插入时，如果数组位置上已经有元素，1.7将新元素放到数组中，原始节点作为新节点的后继节点，1.8遍历链表，将元素放置到链表的最后；\n\\3.    扩容的时候1.7需要对原数组中的元素进行重新hash定位在新数组的位置，1.8采用更简单的判断逻辑，位置不变或索引+旧容量大小；\n\\4.    在插入时，1.7先判断是否需要扩容，再插入，1.8先进行插入，插入完成再判断是否需要扩容；\n为什么这样优化：\n1.防止发生hash冲突，链表长度过长，将时间复杂度由O(n)降为O(logn);\n2.因为1.7头插法扩容时，头插法会使链表发生反转，多线程环境下会产生环；\n3.这是由于扩容是扩大为原数组大小的2倍，用于计算数组位置的掩码仅仅只是高位多了一个1。即hash的新一位是1，位置需要发生变化，如果是0，就保持不变。\nJDK1.8的hasnMap仍然是线程不安全的，会出现覆盖数据的现象，但不会发生死锁了。以1.8为例，当A线程判断index位置为空后正好挂起，B线程开始往index位置的写入节点数据，这时A线程恢复现场，执行赋值操作，就把A线程的数据给覆盖了；还有++size这个地方也会造成多线程同时扩容等问题。‘\nHashTable是直接在操作方法上加synchronized关键字，锁住整个数组，粒度比较大，Collections.synchronizedMap是使用Collections集合工具的内部类，通过传入Map封装出一个SynchronizedMap对象，内部定义了一个对象锁，方法内通过对象锁实现；ConcurrentHashMap使用分段锁，降低了锁粒度，让并发度大大提高。\nhashMap的无序的，如果想实现有序的HashMap，可以使用 LinkedHashMap 和 TreeMap， LinkedHashMap内部维护了一个单链表，有头尾节点，同时LinkedHashMap节点Entry内部除了继承HashMap的Node属性，还有before 和 after用于标识前置节点和后置节点。可以实现按插入的顺序或访问顺序排序；TreeMap是按照Key的自然顺序或者Comprator的顺序进行排序，内部是通过红黑树来实现。所以要么key所属的类实现Comparable接口，或者自定义一个实现了Comparator接口的比较器，传给TreeMap用于key的比较。\nConcurrentHashMapConcurrentHashMap成员变量使用volatile 修饰，免除了指令重排序，同时保证内存可见性，另外使用CAS操作和synchronized结合实现赋值操作，多线程操作只会锁住当前操作索引的节点。\nConcurrentHashMap可以做到读取数据不加锁，并且其内部的结构可以让其在进行写操作的时候能够将锁的粒度保持地尽量地小，不用对整个ConcurrentHashMap加锁。\n即线程A锁住A节点所在链表，线程B锁住B节点所在链表，操作互不干涉。\nConcurrentHashMap比HashMap多了一次hash过程，即经历了两次hash过程，第1次hash定位到Segment，第2次hash定位到HashEntry，然后链表搜索找到指定节点。\n第一次hash的过程：\nhash &gt;&gt;&gt; (32-sshift) = hash &gt;&gt;&gt; segmentShift\n其中，2的sshift次方是Segment数量，假设，sshift为4，则Segment的数量为16，而hash经过上面计算，右移了28位，只剩最高为的4个值，这样就可以计算数据应该存放在哪个Segment桶中。\n第二次hash的过程，和普通hashMap一样，和2的n次方减1进行与运算。JDK1.7版本，一个Segment内部可以单独看成一个HashMap，经过与运算，把数据存放在当前Segement的hash桶中，如果同一个桶中有多个数据，则使用链表结构。\nconcurrencyLevel： ConcurrentHashMap内部的Segment的数量。\nconcurrencyLevel一经指定，便不能再次改变，原因也很简单，简化元素增多时的rehash过程，若Segment的数量也随元素的增加而进行扩容，则需要进行两次rehash，需要处理全部元素，效率较低。\nConcurrentHashMap不会增加Segment的数量，而只会增加Segment中链表数组的容量大小，这样的好处是扩容过程不需要对整个ConcurrentHashMap做rehash，而只需要对Segment里面的元素做一次rehash就可以了。\nConcurrentHashMap的put方法与普通HashMap类似，remove方法需要注意；\n由于，HashEntry中的next是final的，一经赋值以后就不可修改，在定位到待删除元素的位置以后，程序就将待删除元素前面的那一些元素全部复制一遍，然后再一个一个重新接到链表上去：\n// 原有链表：\n1–&gt;2–&gt;3–&gt;4–&gt;5\n// 删除节点3，新的链表为：\n2–&gt;1–&gt;4–&gt;5\nJDK1.8之后，弃用了Segment，改用数组加链表以及红黑树的方式，和普通的hashMap一样了。JDK1.8之后采用了原子类，通过CAS和Synchronized来完成数据的可靠性。JDK1.7之前，时对整个Segment加锁，而1.8是对数组种的一个元素Node来加锁，一个Node包含了key，value值，锁的粒度更小。\n解决hashmaphash冲突常用的方法：\\1.    开放地址法：发送hash冲突时，就对对象的hahs值加1，重新计算位置，直到找到空置位为止。\n\\2.    再hash法：发送hash冲突，就使用其他的方法计算hashcode，直到不冲突为止\n\\3.    链地址法：发送hash冲突时，以链表的形式，把不同的对象存在同一个位置。\n\\4.    建立公共溢出栈：建立一个溢出表，把所有hash冲突的对象都放在这个表中\n","categories":[],"tags":[]},{"title":"Java基础知识阶段性整理","url":"https://sacharn.github.io/2021/04/22/Java基础知识阶段性整理/","content":"01 谈谈对面向对象思想的理解首先，谈谈“面向过程”vs“面向对象”\n我觉得这两者是思考角度的差异，面向过程更多是以“执行者”的角度来思考问题，而面向对象更多是以“组织者”的角度来思考问题，举个例子，比如我要产生一个0-10之间的随机数，如果以“面向过程”的思维，那我更多是关注如何去设计一个算法，然后保证比较均衡产生0-10的随机数，而面向对象的思维会更多关注，我找谁来帮我们做这件事，比如Random类，调用其中提供的方法即可。\n02 JDK，JRE，JVM有什么区别？\nJDK ：Java Development Kit，Java开发工具包，提供了Java的开发环境和运行环境。\n包含了编译Java源文件的编译器Javac，还有调试和分析的工具。\nJRE ：Java Runtime Environment，Java运行环境，包含Java虚拟机及一些基础类库\nJVM ：Java Virtual Machine，Java虚拟机，提供执行字节码文件的能力\n\n所以，如果只是运行Java程序，只需要安装JRE即可。\n另外注意，JVM是实现Java跨平台的核心，但JVM本身并不是跨平台的，\n不同的平台需要安装不同的JVM\n\n03 ==和equals的区别\n基本数据类型存在栈内存中\n引用数据类型地址值存在栈内存中，引用对象存在堆内存中\n\n== 比较的是值\n\n比较基本的数据类型，比较的是数值\n比较引用类型：比较引用指向的值（地址）\n\nequals\n默认比较也是地址，因为这个方法的最初定义在Object上，默认的实现就是比较地址\n自定义的类，如果需要比较的是内容，那么就要学String，重写equals方法\n04 final的作用\nfinal修饰类，表示类不可变，不可继承 比如，String，不可变性\nfinal修饰方法，表示该方法不可重写\nfinal修饰变量，这个变量就是常量\n\n注意：\n\n修饰的是基本数据类型，这个值本身不能修改\n修饰的是引用类型，引用的指向不能修改\n\n比如下面的代码是可以的\nfinal Student student = new Student(1,&quot;Andy&quot;);student.setAge(18);//注意，这个是可以的！\n\nstudent = new Student();//这个不可以！\n\n05 String s = “java”与String s = new String(“java”)String s = &quot;java&quot;;\n\nString s = new String(&quot;java&quot;);\n\n这两者的内存分配方式是不一样的。\n第一种方式，JVM会将其分配到常量池，而第二种方式是分配到堆内存\n代码案例：测试以下的每道题，你是否能够正确得到答案？\nString s1 = new String(&quot;zs&quot;);String s2 = new String(&quot;zs&quot;);System.out.println(s1 == s2);//false，存在于两个不同的堆内存String s3 = &quot;zs&quot;;String s4 = &quot;zs&quot;;System.out.println(s3 == s4);//相当于常量比较，trueSystem.out.println(s3 == s1);//常量池地址和堆地址,falseString s5 = &quot;zszs&quot;;String s6 = s3+s4;System.out.println(s5 == s6);//false 一个常量池地址，一个堆地址（String是不可变对象，当使用拼接符号时，会new一个新对象，所以是对应堆地址）final String s7 = &quot;zs&quot;;final String s8 = &quot;zs&quot;;String s9 = s7+s8;//对于常量（final修饰），编译器在拼接时会进行优化，拼接后还是常量System.out.println(s5 == s9);//truefinal String s10 = s3+s4;System.out.println(s5 == s10);//false 常量池和堆内存\n\n06 String，StringBuffer，StringBuilder区别String 跟其他两个类的区别是\n\nString是final类型，每次声明的都是不可变的对象，所以每次操作都会产生新的String对象，然后将指针指向新的String对象。\n\nStringBuffer，StringBuilder都是在原有对象上进行操作\n\n所以，如果需要经常改变字符串内容，则建议采用这两者。\n\nStringBuffer vs StringBuilder\n\n前者是线程安全的（每个方法都加了synchronized修饰），后者是线程不安全的。线程不安全性能更高，所以在开发中，优先采用StringBuilder.因为局部变量每个线程独享，根本不存在线程安全问题。例如add()方法调用，对应虚拟机栈栈帧，是线程私有的。也即是说每个线程里面都有一份数据，并不会影响操作结果。当多个线程访问同一个资源时才会出现线程安全问题，此时的场景中并不会发生这个问题。StringBuilder &gt; StringBuffer &gt; String\n\n一个对象是线程安全的？1、多线程环境下2、对这个对象的访问不加额外的同步控制（synchronized等）3、操作的数据的结果依然是正确的\n\n07 接口和抽象类的区别这个问题，要分JDK版本来区分回答：\n\nJDK 1.8之前：\n\n\n语法：\n\n\n抽象类：方法可以有抽象的，也可以有非抽象, 有构造器\n接口：方法都是抽象，属性都是常量，默认有public static final修饰\n\n\n设计：\n\n\n抽象类：同一类事物的抽取，比如针对 Dao 层操作的封装，如，BaseDao，BaseServiceImpl\n接口：通常更像是一种标准的制定，定制系统之间对接的标准\n例子：\n1，单体项目，分层开发，interface作为各层之间的纽带，在controller中注入IUserService，在Service注入IUserDao\n2，分布式项目，面向服务的开发，抽取服务service，这个时候，就会产生服务的提供者和服务的消费者两个角色\n这两个角色之间的纽带，依然是接口\n\n\n\n\nJDK 1.8之后：\n\n\n接口里面可以有实现的方法，注意要在方法的声明上加上default或者static\n\n\n\n最后区分几个概念：\n\n多继承，多重继承，多实现\n\n\n多重继承：A-&gt;B-&gt;C（爷孙三代的关系）\n多实现：Person implements IRunable ,IEatable（符合多项国际化标准）\n多继承：接口可以多继承，类只支持单继承\n\n\n\n08 09 N的阶乘和斐波那契数列什么是递归？\n\n递归，就是方法内部调用方法自身递归的注意事项：找到规律，编写递归公式找到出口（边界值），让递归有结束边界注意：如果递归太多层，或者没有正确结束递归，则会出现“栈内存溢出Error”！问题：为什么会出现栈内存溢出，而不是堆内存溢出？\n\n10 什么是向上转型？什么是向下转型？举例说明即可：\n\n向上转型：Person person = new Student(); 安全的向下转型：Teacher teacher = (Teacher)person; 不安全的\n\n11 Int和Integer的区别（重点）Integer i1 = new Integer(12);      Integer i2 = new Integer(12);      System.out.println(i1 == i2);      Integer i3 = 126;      Integer i4 = 126;      int i5 = 126;      System.out.println(i3 == i4);      System.out.println(i3 == i5);      Integer i6 = 128;      Integer i7 = 128;      int i8 = 128;      System.out.println(i6 == i7);      System.out.println(i6 == i8);\n\n答案揭晓\n分情况来比较\n\n都定义为Integer的比较：\n\n\nnew：一旦new，就是开辟一块新内存，结果肯定是false不new：看范围Integer做了缓存，-128至127，当你取值在这个范围的时候，会采用缓存的对象，所以会相等当不在这个范围，内部创建新的对象，此时不相等\n\n\nInteger和int的比较：\n\n\n实际比较的是数值，Integer会做拆箱的动作，来跟基本数据类型做比较此时跟是否在缓存范围内或是否new都没关系\n\n源码分析：\n\n当我们写\nInteger i &#x3D; 126\n\n,实际上做了自动装箱：\nInteger i &#x3D; Integer.valueOf(126);\n\n分析这段源码\n\npublic static Integer valueOf(int i) &#123;    if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)        return IntegerCache.cache[i + (-IntegerCache.low)];    return new Integer(i);&#125;//IntegerCache是Integer的内部类private static class IntegerCache &#123;    static final int low = -128;    static final int high;    static final Integer cache[];    static &#123;        // high value may be configured by property        int h = 127;\n\n12 方法的重写和重载的区别\n重载：发生在一个类里面，方法名相同，参数列表不同（混淆点：跟返回类型没关系）\n\n\n以下不构成重载(如果方法名和参数列表一样，在调用方法时不知道选择哪一个)\npublic double add(int a,int b)public int add(int a,int b)\n\n\n\n\n重写：发生在父类子类之间的，方法名相同，参数列表相同,返回值类型相同或者子类的返回值类型为父类的子类。\n\n13 冒泡排序每次冒泡排序都会对相邻的两个元素进行比较，如果前面的元素比后面的元素大，则进行互换，一次冒泡会至少让一个元素移动到它应该在的位置。（第一次冒泡就是让最大的数到最右边，第二次就是次大的到此最右的位置，以此类推）重复n次，就完成n个元素的排序工作。\n关于上面的优化思考\n\n其实，当某次冒泡操作没有数据交换时，说明已经达到了完全有序，不用再继续后续的冒泡操作。\n\npublic void bubbleSort(int[] array)&#123;    if(array.length &lt;= 1)&#123;        return;    &#125;    //重复n次冒泡    for(int i=0;i&lt;array.length;i++)&#123;        //是否可以提交退出冒泡的标记        boolean flag = false;        //相邻之间两两比较，并且每次减少一位参与比较        for(int j=0;j&lt;array.length-i-1;j++)&#123;            if(array[j] &gt; array[j+1])&#123;                //需要交换                int temp = array[j];                array[j] = array[j+1];                array[j+1] = temp;                //                flag = true;//有数据交换，不能提前退出            &#125;        &#125;        if(!flag)&#123;            //没有数据交换，提前退出冒泡比较            break;        &#125;    &#125;&#125;\n\n15 List和Set的区别\nList（有序，可重复）\nSet（无序，不可重复）\n\n16 谈谈ArrayList和LinkedList的区别1、底层数据结构的差异\n\nArrayList，数组，连续一块内存空间LinkedList，双向链表，不是连续的内存空间\n\n 2、一个常规的结论\n虽然不严谨，但也可以应付很多面试了\n\nArrayList，查找快，因为是连续的内存空间，方便寻址，但删除，插入慢，因为需要发生数据迁移LinkedList，查找慢，因为需要通过指针一个个寻找，但删除，插入块，因为只要改变前后节点的指针指向即可。\n查找分两种：\n\n查找第2个元素，ArrayList连续的内存空间，可计算偏移量，LinkedList只能一个一个找\n查找b在哪？只能一个一个比较ArrayList，LinkedList\n插入到中间，ArrayList要迁移数据\n插入到末尾，ArrayList直接计算，LinkedList有first和last指针。last指针指向尾部。\n\n\n3、ArrayList细节分析\n1、增加\n\n\n添加到末尾，正常不需要做特别的处理，除非现有的数组空间不够了，需要扩容\n\n\n数组初始化容量多大？10，当你知道需要存储多少数据时，建议在创建的时候，直接设置初始化大小\n\n怎么扩容？\n\n\n当发现容量不够之后，就进行扩容\n按原先数组容量的1.5倍进行扩容，位运算，下面是关键的源码\n\n\n\n\n\n\n\nint oldCapacity = elementData.length;int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);//位运算更快\n\n\n\n\n\n再将原先数组的元素复制到新数组，Arrays\n\n\n\n\n\n\n\nelementData = Arrays.copyOf(elementData, newCapacity)\n\n\n\n添加到其他位置，这个时候需要做整体的搬迁\n\n\n2、删除\n\n\n删除末尾，并不需要迁移\n删除其他的位置，这个时候也需要搬迁\n\n\n3、修改\n\n\n修改之前，必须先定位\n定位-查找- ArrayList（数组是一段连续的内存空间，定位会特别快）\n\n\n4、查找\n\n\n如上所述\n\n\n\n4、LinkedList 细节分析\n1、提供了的两个引用（first，last）\n2、增加\n添加到末尾，创建一个新的节点，将之前的last节点设置为新节点的 pre ，新节点设置为last\n我们看下源码：\nvoid linkLast(E e) &#123;    //获取到最后一个节点    final Node&lt;E&gt; l = last;    //构建一个新节点，将当前的last作为这个新节点的pre    final Node&lt;E&gt; newNode = new Node&lt;&gt;(l, e, null);    //把last指向新节点    last = newNode;    //如果原先没有最后一个节点    if (l == null)        //将first指向新节点        first = newNode;    else        //否则，将原先的last的next指向新节点        l.next = newNode;    size++;    modCount++;&#125;Node节点的定义：内部类private static class Node&lt;E&gt; &#123;    E item;    Node&lt;E&gt; next;    Node&lt;E&gt; prev;    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;        this.item = element;        this.next = next;        this.prev = prev;    &#125;&#125;\n\n添加到其他位置，这个时候，就需要调整前后节点的引用指向\n3、如何去定义一个双向链表的节点，如上述的源码所示\n4、修改\n修改最后一个节点或者第一个节点，那么就很快（first，last）\n修改其他位置，如果是按坐标来定位节点，则会按照二分查找法，源码如下：\nif (index &lt; (size &gt;&gt; 1)) &#123;    Node&lt;E&gt; x = first;    for (int i = 0; i &lt; index; i++)        x = x.next;    return x;&#125; else &#123;    Node&lt;E&gt; x = last;    for (int i = size - 1; i &gt; index; i--)        x = x.prev;    return x;&#125;\n\n\n\n5、一个思考题，假如我们可以确定要存储1000个元素，那么采用ArrayList和LinkedList，\n哪个更耗内存，为什么？\nLinkedlist更消耗内存，因为已经确定了元素个数，而LinkedList不仅要存data本身还要额外存pre和next指针。\n\n17 LinkedList，要实现在A和B之间插入C，该如何实现，编写伪代码即可C.pre = A;C.next = A.next;A.next.pre = C;A.next = C;\n\n56 说说常用的聚合函数有哪些及作用？\n基本使用语法：\nselect max(age) from t_student;select min(age) from t_student;\n\n聚合函数经常会结合分组查询，出现在众多的SQL笔试题中，对于SQL笔试题，唯有多练\n57 左连接，右连接，内连接，如何编写 SQL ，他们的区别是什么？左连接：以左表为主\n\nselect a.,b. from a left join b on a.b_id = b.id;\n\n右连接：以右表为主\n\nselect a.,b. from a right join b on a.b_id = b.id;\n\n内连接：只列出两张表关联查询符合条件的记录\n\nselect a.,b. from a inner join b on a.b_id = b.id;\n\n案例：\nselect t.id t_id,t.name t_name,c.id c_id,c.name c_name\n from t_teacher t LEFT JOIN t_class c on t.id= c.t_id; #4条，以老师表为主\nselect t.id t_id,t.name t_name,c.id c_id,c.name c_name\n from t_teacher t RIGHT JOIN t_class c on t.id=c.t_id; #4条，以班级表为主\nselect t.id t_id,t.name t_name,c.id c_id,c.name c_name\n from t_teacher t INNER JOIN t_class c on t.id=c.t_id; #3条，只展示匹配条件的记录\n","categories":[],"tags":[]},{"title":"生鲜项目总结","url":"https://sacharn.github.io/2021/04/14/生鲜项目总结/","content":"\n","categories":[],"tags":[]},{"title":"面经问题整理","url":"https://sacharn.github.io/2021/03/23/面经问题整理/","content":"1、Get和Post请求的区别\n哪一些情况下，浏览器会发送get请求\n​        a. 直接在浏览器地址栏输入某个地址\n​        b. 点击链接\n​        c. 表单默认的提交方式\n\n 哪一些情况下，浏览器会发送post请求？\n\n\n  ​        a. 设置表单method = “post”\n\n get请求的特点\n\n  ​        a. 请求参数会添加到请求资源路劲的后面，只能添加少量参数（因为请求行只有一行，大约只能存放2K左右的数据）（2K左右的数据，看起来也不少。。。）\n  ​        b. 请求参数会显示在浏览器地址栏，路由器会记录请求地址（不安全，容易泄露信息）\n\n post请求的特点\n\n  ​        a. 请求参数添加到实体内容里面，可以添加大量的参数（也解释了为什么浏览器地址栏不能发送post请求，在地址栏里我们只能填写URL，并不能进入到Http包的实体当中）\n  ​        b. 相对安全，但是post请求不会对请求参数进行加密处理（可以使用https协议来保证数据安全）。\n","categories":[],"tags":[]},{"title":"生鲜项目中的实现细节","url":"https://sacharn.github.io/2021/03/22/生鲜项目中的实现细节/","content":"1、统一异常\n我们需要对这些异常进行统一的捕获并处理。SpringBoot中有一个ControllerAdvice的注解，使用该注解表示开启了全局异常的捕获，我们只需在自定义一个方法使用ExceptionHandler注解然后定义捕获异常的类型即可对这些捕获的异常进行统一的处理。如下为全局异常处理类。\n\npackage com.shu.mall.exception;import com.shu.mall.common.ApiRestResponse;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.validation.BindingResult;import org.springframework.validation.ObjectError;import org.springframework.web.bind.MethodArgumentNotValidException;import org.springframework.web.bind.annotation.ControllerAdvice;import org.springframework.web.bind.annotation.ExceptionHandler;import org.springframework.web.bind.annotation.ResponseBody;import java.util.ArrayList;import java.util.List;//使用该注解代表开启了全局异常捕获@ControllerAdvicepublic class GlobalExceptionHandler &#123;    private final Logger log = LoggerFactory.getLogger(GlobalExceptionHandler.class);    //处理默认异常    @ExceptionHandler(Exception.class)    @ResponseBody    public Object handleException(Exception e)&#123;    log.error(&quot;Default Exception:&quot; ,e);        return ApiRestResponse.error(LiveMallExceptionEnum.SYSTEM_ERROR);    &#125;        //处理业务相关的自定义异常    @ExceptionHandler(LiveMallException.class)    @ResponseBody    public Object handleLiveMallException(LiveMallException e)&#123;        log.error(&quot;LiveMallException:&quot; ,e);        return ApiRestResponse.error(e.getCode(),e.getMessage());    &#125;        //处理参数校验异常    @ExceptionHandler(MethodArgumentNotValidException.class)    @ResponseBody    public ApiRestResponse handleMethodArgumentNotValidException(MethodArgumentNotValidException e)&#123;        log.error(&quot;MethodArgumentNotValidException:&quot;+e);        return handleBindingResult(e.getBindingResult());    &#125;        //把异常处理为对外暴露的提示    private ApiRestResponse handleBindingResult(BindingResult result)&#123;         List&lt;String&gt; list =new ArrayList&lt;&gt;();        if (result.hasErrors()) &#123;            List&lt;ObjectError&gt; allErrors = result.getAllErrors();            for (int i = 0; i &lt; allErrors.size(); i++) &#123;                ObjectError objectError = allErrors.get(i);                String defaultMessage = objectError.getDefaultMessage();                list.add(defaultMessage);            &#125;        &#125;        if (list.size()==0)&#123;            return ApiRestResponse.error(LiveMallExceptionEnum.REQUEST_PARAM_ERROR);        &#125;        return ApiRestResponse.error(LiveMallExceptionEnum.REQUEST_PARAM_ERROR.getCode(),list.toString());    &#125;&#125;\n\n\n如上图代码可知，需要处理的异常分为默认异常、业务相关的异常和参数校验相关异常。在本项目中，业务相关的异常是LiveMallException异常（继承自RuntimeException），成员变量为状态码和状态信息：\n\npackage com.shu.mall.exception;//业务相关异常public class LiveMallException extends RuntimeException&#123;        private final Integer code;    private final String message;    public LiveMallException(Integer code, String message) &#123;        this.code = code;        this.message = message;    &#125;    public LiveMallException(String message, Integer code, String message1) &#123;        super(message);        this.code = code;        this.message = message1;    &#125;    public LiveMallException(String message, Throwable cause, Integer code, String message1) &#123;        super(message, cause);        this.code = code;        this.message = message1;    &#125;    public LiveMallException(Throwable cause, Integer code, String message) &#123;        super(cause);        this.code = code;        this.message = message;    &#125;    public LiveMallException(String message, Throwable cause, boolean enableSuppression, boolean writableStackTrace, Integer code, String message1) &#123;        super(message, cause, enableSuppression, writableStackTrace);        this.code = code;        this.message = message1;    &#125;        public LiveMallException(LiveMallExceptionEnum exceptionEnum)&#123;        this(exceptionEnum.getCode(),exceptionEnum.getMsg());    &#125;    public Integer getCode() &#123;        return code;    &#125;    @Override    public String getMessage() &#123;        return message;    &#125;&#125;\n\n\n\n\n在异常处理中，使用到了自定义枚举。这个主要是在controller层写具体控制器的时候，作为统一返回对象的方法参数使用。\n\npublic static &lt;T&gt; ApiRestResponse&lt;Object&gt; error(LiveMallExceptionEnum ex)&#123;        return new ApiRestResponse&lt;&gt;(ex.getCode(),ex.getMsg());    &#125;\n\n\n\npackage com.shu.mall.exception;//异常枚举public enum LiveMallExceptionEnum &#123;        NEED_UESR_NAME(10001,&quot;用户名不能为空&quot;),    NEED_PASSWORD(10002,&quot;密码不能为空&quot;),    PASSWORD_TOO_SHORT(10003,&quot;密码太短&quot;),    NAME_EXISTED(10004,&quot;不允许重名&quot;),    INSERT_FAILED(10005,&quot;插入失败，请重试&quot;),    WRONG_PASSWORD(10006,&quot;密码错误&quot;),    NEED_LOGIN(10007,&quot;用户未登录&quot;),    UPDATE_FAILED(10008,&quot;更新失败&quot;),    NEED_ADMIN(10009,&quot;无管理员权限&quot;),    PARA_NOT_NULL(10010,&quot;名字不能为空&quot;),    CREATE_FAILED(10011,&quot;创建失败&quot;),    REQUEST_PARAM_ERROR(10012,&quot;请求参数失败&quot;),    DELETE_FAILED(10013,&quot;删除失败&quot;),    MKDIR_FAILED(10014,&quot;文件夹创建失败&quot;),    UPLOAD_FAILED(10015,&quot;上传失败&quot;),    NOT_SALE(10016, &quot;商品状态不可售&quot;),    NOT_ENOUGH(10017, &quot;商品库存不足&quot;),    CART_EMPTY(10018, &quot;购物车已勾选的商品为空&quot;),    NO_ENUM(10019, &quot;未找到对应的枚举&quot;),    NO_ORDER(10020, &quot;订单不存在&quot;),    NOT_YOUR_ORDER(10021, &quot;订单不属于你&quot;),    WRONG_ORDER_STATUS(10022, &quot;订单状态不符&quot;),    SYSTEM_ERROR(20000,&quot;系统错误&quot;);    Integer code;    String msg;        LiveMallExceptionEnum(Integer code, String msg) &#123;        this.code = code;        this.msg = msg;    &#125;    public Integer getCode() &#123;        return code;    &#125;        public void setCode(Integer code) &#123;        this.code = code;    &#125;    public String getMsg() &#123;        return msg;    &#125;    public void setMsg(String msg) &#123;        this.msg = msg;    &#125;    @Override    public String toString() &#123;        return &quot;LiveMallExceptionEnum&#123;&quot; +                &quot;code=&quot; + code +                &quot;, msg=&#x27;&quot; + msg + &#x27;\\&#x27;&#x27; +                &#x27;&#125;&#x27;;    &#125;&#125;\n\n\n\n2、参数校验\n如果不用参数校验，原始的就是if语句，那就太傻了…..\n我们不傻，我们在请求类中用valid参数校验\n\npackage com.shu.mall.model.request;import javax.validation.constraints.Max;import javax.validation.constraints.NotNull;import javax.validation.constraints.Size;//添加目录的请求类public class AddCategoryReq &#123;    @Size(min =2,max=5)    @NotNull(message = &quot;name:不能为null&quot;)    private String name;    @Max(3)    @NotNull(message = &quot;type:不能为null&quot;)    private Integer type;    @NotNull(message = &quot;parentId:不能为null&quot;)    private Integer parentId;    @NotNull(message = &quot;orderNum:不能为null&quot;)    private Integer orderNum;    public String getName() &#123;        return name;    &#125;    public void setName(String name) &#123;        this.name = name;    &#125;    public Integer getType() &#123;        return type;    &#125;    public void setType(Integer type) &#123;        this.type = type;    &#125;    public Integer getParentId() &#123;        return parentId;    &#125;    public void setParentId(Integer parentId) &#123;        this.parentId = parentId;    &#125;    public Integer getOrderNum() &#123;        return orderNum;    &#125;    public void setOrderNum(Integer orderNum) &#123;        this.orderNum = orderNum;    &#125;    @Override    public String toString() &#123;        return &quot;AddCategoryReq&#123;&quot; +                &quot;name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; +                &quot;, type=&quot; + type +                &quot;, parentId=&quot; + parentId +                &quot;, orderNum=&quot; + orderNum +                &#x27;&#125;&#x27;;    &#125;&#125;\n\n\n\n3、统一响应package com.shu.mall.common;import com.shu.mall.exception.LiveMallExceptionEnum;//返回通用接口public class ApiRestResponse&lt;T&gt; &#123;    //状态码    private Integer status;    //信息    private String msg;    //泛型，数据类型不固定，表示数据    private T data;    private static final int OK_CODE = 10000;    private static final String OK_MSG = &quot;SUCCESS&quot;;    public Integer getStatus() &#123;        return status;    &#125;    public void setStatus(Integer status) &#123;        this.status = status;    &#125;    public String getMsg() &#123;        return msg;    &#125;    public void setMsg(String msg) &#123;        this.msg = msg;    &#125;    public T getData() &#123;        return data;    &#125;    public void setData(T data) &#123;        this.data = data;    &#125;    public static int getOkCode() &#123;        return OK_CODE;    &#125;    public static String getOkMsg() &#123;        return OK_MSG;    &#125;    public ApiRestResponse(Integer status, String msg, T data) &#123;        this.status = status;        this.msg = msg;        this.data = data;    &#125;    public ApiRestResponse(Integer status, String msg) &#123;        this.status = status;        this.msg = msg;    &#125;    public ApiRestResponse() &#123;        this(OK_CODE,OK_MSG);    &#125;    public static &lt;T&gt; ApiRestResponse&lt;T&gt; success()&#123;        return new ApiRestResponse&lt;&gt;();    &#125;    public static &lt;T&gt; ApiRestResponse&lt;Object&gt; success(T result)&#123;        ApiRestResponse&lt;Object&gt; response = new ApiRestResponse&lt;&gt;();        response.setData(result);        return response;    &#125;    public static &lt;T&gt; ApiRestResponse&lt;Object&gt; error(Integer code ,String msg)&#123;        return new ApiRestResponse&lt;&gt;(code,msg);    &#125;    public static &lt;T&gt; ApiRestResponse&lt;Object&gt; error(LiveMallExceptionEnum ex)&#123;        return new ApiRestResponse&lt;&gt;(ex.getCode(),ex.getMsg());    &#125;&#125;\n\n4、Redis缓存的使用\n首先，在pom.xml文件中添加依赖\n\n&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-cache&lt;/artifactId&gt;&lt;/dependency&gt;\n\n\n然后，在启动类中使用@EnableCaching注解启动缓存\n\npackage com.shu.mall;import org.mybatis.spring.annotation.MapperScan;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cache.annotation.EnableCaching;import springfox.documentation.swagger2.annotations.EnableSwagger2;/** * @author 严树成 */@SpringBootApplication@MapperScan(basePackages = &quot;com.shu.mall.model.dao&quot;)@EnableSwagger2@EnableCachingpublic class MallApplication &#123;    public static void main(String[] args) &#123;        SpringApplication.run(MallApplication.class, args);    &#125;&#125;\n\n\n然后，在application.properties中配置Redis的主机号和端口号（注意，记住端口号6379！）\n\nspring.redis.host=localhostspring.redis.port=6379\n\n\n然后，配置CacheManager,设置缓存持续时间为30s\n\npackage com.shu.mall.config;import org.springframework.cache.annotation.EnableCaching;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.data.redis.cache.RedisCacheConfiguration;import org.springframework.data.redis.cache.RedisCacheManager;import org.springframework.data.redis.cache.RedisCacheWriter;import org.springframework.data.redis.connection.RedisConnectionFactory;import java.time.Duration;@Configuration@EnableCachingpublic class CachingConfig &#123;    @Bean    public RedisCacheManager redisCacheManager(RedisConnectionFactory connectionFactory)&#123;        RedisCacheWriter redisCacheWriter = RedisCacheWriter                .lockingRedisCacheWriter(connectionFactory);        RedisCacheConfiguration cacheConfiguration = RedisCacheConfiguration.defaultCacheConfig();        cacheConfiguration = cacheConfiguration.entryTtl(Duration.ofSeconds(30));        RedisCacheManager redisCacheManager = new RedisCacheManager(redisCacheWriter,                cacheConfiguration);        return redisCacheManager;    &#125;&#125;\n\n\n使用Redis，在service层的实现类中，在面向用户的商品列表查询的接口实现中添加**@Cacheable注解**\n\n@Override    @Cacheable(value = &quot;listCategoryForCustomer&quot;)    public List&lt;CategoryVo&gt; listCategoryForCustomer(Integer parentId)&#123;        ArrayList&lt;CategoryVo&gt; categoryVoList = new ArrayList&lt;&gt;();        recursivelyFindCategories(categoryVoList,0);        return categoryVoList;    &#125;\n\n5、SpringBoot整合MyBatis配置\n首先，pom.xml的依赖\n\n&lt;dependency&gt;          &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;          &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;          &lt;version&gt;1.3.2&lt;/version&gt;      &lt;/dependency&gt;      &lt;dependency&gt;          &lt;groupId&gt;mysql&lt;/groupId&gt;          &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;      &lt;/dependency&gt;\n\n\napplication.properties配置（数据库驱动、用户名和密码、url、端口号、mapper文件所在路径）\n\nspring.datasource.driver-class-name=com.mysql.cj.jdbc.Driverspring.datasource.username=rootspring.datasource.password=ysc223spring.datasource.url=jdbc:mysql://localhost:3306/imooc_mall?useUnicode=true&amp;characterEncoding=UTF-8&amp;useSSL=false&amp;serverTimezone=GMTserver.port=8083mybatis.mapper-locations=classpath:mappers/*.xml\n\n\nmapper映射（dao层Mapper接口–&gt;Mapper.xml文件）\n\npackage com.shu.mall.model.dao;import com.shu.mall.model.pojo.User;import org.apache.ibatis.annotations.Param;import org.springframework.stereotype.Repository;/** * @author 严树成 * @describe 用户接口。包含增删改查用户信息的抽象方法。 */@Repositorypublic interface UserMapper &#123;    /**     * @describe 根据主键删除用户     * @param id ，Integer类型     * @return     */    int deleteByPrimaryKey(Integer id);    /**     * @describe 插入用户     * @param record ，User类型     * @return     */    int insert(User record);    /**     * @describe 选择性的插入用户     * @param record     * @return     */    int insertSelective(User record);    /**     * @describe 根据主键查询     * @param id     * @return 用户 User类型     */    User selectByPrimaryKey(Integer id);    /**     * @describe 根据主键选择的更新     * @param record     * @return     */    int updateByPrimaryKeySelective(User record);    /**     * @describe 通过主键更新     * @param record     * @return     */    int updateByPrimaryKey(User record);    /**     * @param userName     * @return     */    User selectByName(String userName);    User selectLogin(@Param(&quot;userName&quot;) String userName, @Param(&quot;password&quot;) String password);&#125;\n\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.shu.mall.model.dao.UserMapper&quot;&gt;  &lt;resultMap id=&quot;BaseResultMap&quot; type=&quot;com.shu.mall.model.pojo.User&quot;&gt;    &lt;id column=&quot;id&quot; jdbcType=&quot;INTEGER&quot; property=&quot;id&quot; /&gt;    &lt;result column=&quot;username&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;username&quot; /&gt;    &lt;result column=&quot;password&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;password&quot; /&gt;    &lt;result column=&quot;personalized_signature&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;personalizedSignature&quot; /&gt;    &lt;result column=&quot;role&quot; jdbcType=&quot;INTEGER&quot; property=&quot;role&quot; /&gt;    &lt;result column=&quot;create_time&quot; jdbcType=&quot;TIMESTAMP&quot; property=&quot;createTime&quot; /&gt;    &lt;result column=&quot;update_time&quot; jdbcType=&quot;TIMESTAMP&quot; property=&quot;updateTime&quot; /&gt;  &lt;/resultMap&gt;  &lt;sql id=&quot;Base_Column_List&quot;&gt;    id, username, `password`, personalized_signature, `role`, create_time, update_time  &lt;/sql&gt;  &lt;select id=&quot;selectByPrimaryKey&quot; parameterType=&quot;java.lang.Integer&quot; resultMap=&quot;BaseResultMap&quot;&gt;    select     &lt;include refid=&quot;Base_Column_List&quot; /&gt;    from imooc_mall_user    where id = #&#123;id,jdbcType=INTEGER&#125;  &lt;/select&gt;  &lt;delete id=&quot;deleteByPrimaryKey&quot; parameterType=&quot;java.lang.Integer&quot;&gt;    delete from imooc_mall_user    where id = #&#123;id,jdbcType=INTEGER&#125;  &lt;/delete&gt;  &lt;insert id=&quot;insert&quot; parameterType=&quot;com.shu.mall.model.pojo.User&quot;&gt;    insert into imooc_mall_user (id, username, `password`,       personalized_signature, `role`, create_time,       update_time)    values (#&#123;id,jdbcType=INTEGER&#125;, #&#123;username,jdbcType=VARCHAR&#125;, #&#123;password,jdbcType=VARCHAR&#125;,       #&#123;personalizedSignature,jdbcType=VARCHAR&#125;, #&#123;role,jdbcType=INTEGER&#125;, #&#123;createTime,jdbcType=TIMESTAMP&#125;,       #&#123;updateTime,jdbcType=TIMESTAMP&#125;)  &lt;/insert&gt;  &lt;insert id=&quot;insertSelective&quot; parameterType=&quot;com.shu.mall.model.pojo.User&quot;&gt;    insert into imooc_mall_user    &lt;trim prefix=&quot;(&quot; suffix=&quot;)&quot; suffixOverrides=&quot;,&quot;&gt;      &lt;if test=&quot;id != null&quot;&gt;        id,      &lt;/if&gt;      &lt;if test=&quot;username != null&quot;&gt;        username,      &lt;/if&gt;      &lt;if test=&quot;password != null&quot;&gt;        `password`,      &lt;/if&gt;      &lt;if test=&quot;personalizedSignature != null&quot;&gt;        personalized_signature,      &lt;/if&gt;      &lt;if test=&quot;role != null&quot;&gt;        `role`,      &lt;/if&gt;      &lt;if test=&quot;createTime != null&quot;&gt;        create_time,      &lt;/if&gt;      &lt;if test=&quot;updateTime != null&quot;&gt;        update_time,      &lt;/if&gt;    &lt;/trim&gt;    &lt;trim prefix=&quot;values (&quot; suffix=&quot;)&quot; suffixOverrides=&quot;,&quot;&gt;      &lt;if test=&quot;id != null&quot;&gt;        #&#123;id,jdbcType=INTEGER&#125;,      &lt;/if&gt;      &lt;if test=&quot;username != null&quot;&gt;        #&#123;username,jdbcType=VARCHAR&#125;,      &lt;/if&gt;      &lt;if test=&quot;password != null&quot;&gt;        #&#123;password,jdbcType=VARCHAR&#125;,      &lt;/if&gt;      &lt;if test=&quot;personalizedSignature != null&quot;&gt;        #&#123;personalizedSignature,jdbcType=VARCHAR&#125;,      &lt;/if&gt;      &lt;if test=&quot;role != null&quot;&gt;        #&#123;role,jdbcType=INTEGER&#125;,      &lt;/if&gt;      &lt;if test=&quot;createTime != null&quot;&gt;        #&#123;createTime,jdbcType=TIMESTAMP&#125;,      &lt;/if&gt;      &lt;if test=&quot;updateTime != null&quot;&gt;        #&#123;updateTime,jdbcType=TIMESTAMP&#125;,      &lt;/if&gt;    &lt;/trim&gt;  &lt;/insert&gt;  &lt;update id=&quot;updateByPrimaryKeySelective&quot; parameterType=&quot;com.shu.mall.model.pojo.User&quot;&gt;    update imooc_mall_user    &lt;set&gt;      &lt;if test=&quot;username != null&quot;&gt;        username = #&#123;username,jdbcType=VARCHAR&#125;,      &lt;/if&gt;      &lt;if test=&quot;password != null&quot;&gt;        `password` = #&#123;password,jdbcType=VARCHAR&#125;,      &lt;/if&gt;      &lt;if test=&quot;personalizedSignature != null&quot;&gt;        personalized_signature = #&#123;personalizedSignature,jdbcType=VARCHAR&#125;,      &lt;/if&gt;      &lt;if test=&quot;role != null&quot;&gt;        `role` = #&#123;role,jdbcType=INTEGER&#125;,      &lt;/if&gt;      &lt;if test=&quot;createTime != null&quot;&gt;        create_time = #&#123;createTime,jdbcType=TIMESTAMP&#125;,      &lt;/if&gt;      &lt;if test=&quot;updateTime != null&quot;&gt;        update_time = #&#123;updateTime,jdbcType=TIMESTAMP&#125;,      &lt;/if&gt;    &lt;/set&gt;    where id = #&#123;id,jdbcType=INTEGER&#125;  &lt;/update&gt;  &lt;update id=&quot;updateByPrimaryKey&quot; parameterType=&quot;com.shu.mall.model.pojo.User&quot;&gt;    update imooc_mall_user    set username = #&#123;username,jdbcType=VARCHAR&#125;,      `password` = #&#123;password,jdbcType=VARCHAR&#125;,      personalized_signature = #&#123;personalizedSignature,jdbcType=VARCHAR&#125;,      `role` = #&#123;role,jdbcType=INTEGER&#125;,      create_time = #&#123;createTime,jdbcType=TIMESTAMP&#125;,      update_time = #&#123;updateTime,jdbcType=TIMESTAMP&#125;    where id = #&#123;id,jdbcType=INTEGER&#125;  &lt;/update&gt;  &lt;select id=&quot;selectByName&quot; parameterType=&quot;java.lang.String&quot;          resultMap=&quot;BaseResultMap&quot;&gt;            select            &lt;include refid=&quot;Base_Column_List&quot;/&gt;              from imooc_mall_user              where username =#&#123;userName,jdbcType=VARCHAR&#125;  &lt;/select&gt;  &lt;select id=&quot;selectLogin&quot; parameterType=&quot;map&quot;          resultMap=&quot;BaseResultMap&quot;&gt;    select    &lt;include refid=&quot;Base_Column_List&quot;/&gt;    from imooc_mall_user    where username =#&#123;userName,jdbcType=VARCHAR&#125;    and password=#&#123;password&#125;  &lt;/select&gt;&lt;/mapper&gt;\n\n6、使用AOP统一处理Web请求日志（面向切面编程和日志,在项目中也属于过滤器的一部分）\n首先，在pom.xml导入web模块\n\n&lt;dependency&gt;          &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;          &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;          &lt;exclusions&gt;              &lt;exclusion&gt;                  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;                  &lt;artifactId&gt;spring-boot-starter-logging&lt;/artifactId&gt;              &lt;/exclusion&gt;          &lt;/exclusions&gt;      &lt;/dependency&gt;\n\n\n引入AOP依赖和log4j2日志依赖\n\n&lt;dependency&gt;          &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;          &lt;artifactId&gt;spring-boot-starter-log4j2&lt;/artifactId&gt;      &lt;/dependency&gt;      &lt;dependency&gt;          &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;          &lt;artifactId&gt;spring-boot-starter-aop&lt;/artifactId&gt;      &lt;/dependency&gt;\n\n\n实现Web层面的日志切面\n使用@Aspect注解将一个java类定义为切面类\n使用@Pointcut定义一个切入点，可以是一个规则表达式，比如下例中某个package下的所有函数，也可以是一个注解等。\n使用@Before在切入点开始处切入内容\n使用@After在切入点结尾处切入内容\n使用@AfterReturning在切入点return内容之后切入内容（可以用来对处理返回值做一些加工处理）\n\n\npackage com.shu.mall.filter;import com.fasterxml.jackson.core.JsonProcessingException;import com.fasterxml.jackson.databind.ObjectMapper;import org.aspectj.lang.JoinPoint;import org.aspectj.lang.annotation.AfterReturning;import org.aspectj.lang.annotation.Aspect;import org.aspectj.lang.annotation.Before;import org.aspectj.lang.annotation.Pointcut;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.stereotype.Component;import org.springframework.web.context.request.RequestContextHolder;import org.springframework.web.context.request.ServletRequestAttributes;import javax.servlet.http.HttpServletRequest;import java.util.Arrays;@Aspect@Componentpublic class WebLogAspect &#123;    private final Logger log = LoggerFactory.getLogger(WebLogAspect.class);    @Pointcut(&quot;execution(public * com.shu.mall.controller.*.*(..))&quot;)    public void webLog() &#123;    &#125;    @Before(&quot;webLog()&quot;)    public void doBefore(JoinPoint joinPoint) &#123;        //收到请求，记录请求记录        ServletRequestAttributes attributes = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();        HttpServletRequest request = attributes.getRequest();        log.info(&quot;URL:&quot; + request.getRequestURL().toString());        log.info(&quot;HTTP_METHOD:&quot; + request.getMethod());        log.info(&quot;IP:&quot; + request.getRemoteAddr());        log.info(&quot;CLASS_METHOD:&quot; + joinPoint.getSignature().getDeclaringTypeName() + &quot;.&quot; + joinPoint.getSignature().getName());        log.info(&quot;ARGS:&quot; + Arrays.toString(joinPoint.getArgs()));    &#125;    @AfterReturning(returning = &quot;res&quot;, pointcut = &quot;webLog()&quot;)    public void doAfterReturning(Object res) throws JsonProcessingException &#123;        //处理完请求，返回内容        log.info(&quot;RESPONSE:&quot; + new ObjectMapper().writeValueAsString(res));    &#125;&#125;\n\n7、用户控制器（Session、登录状态判断、权限管理、过滤器）\n面向用户的如下，主要判断是否处于登录状态\n\npackage com.shu.mall.filter;import com.shu.mall.common.Constant;import com.shu.mall.model.pojo.User;import com.shu.mall.service.UserService;import java.io.IOException;import java.io.PrintWriter;import javax.servlet.Filter;import javax.servlet.FilterChain;import javax.servlet.FilterConfig;import javax.servlet.ServletException;import javax.servlet.ServletRequest;import javax.servlet.ServletResponse;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import javax.servlet.http.HttpServletResponseWrapper;import javax.servlet.http.HttpSession;import org.springframework.beans.factory.annotation.Autowired;/** * 描述：     用户过滤器 */public class UserFilter implements Filter &#123;    public static User currentUser;    @Autowired    UserService userService;    @Override    public void init(FilterConfig filterConfig) throws ServletException &#123;    &#125;    @Override    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse,            FilterChain filterChain) throws IOException, ServletException &#123;        HttpServletRequest request = (HttpServletRequest) servletRequest;        HttpSession session = request.getSession();        currentUser = (User) session.getAttribute(Constant.LIVE_MALL_USER);        if (currentUser == null) &#123;            PrintWriter out = new HttpServletResponseWrapper(                    (HttpServletResponse) servletResponse).getWriter();            out.write(&quot;&#123;\\n&quot;                    + &quot;    \\&quot;status\\&quot;: 10007,\\n&quot;                    + &quot;    \\&quot;msg\\&quot;: \\&quot;NEED_LOGIN\\&quot;,\\n&quot;                    + &quot;    \\&quot;data\\&quot;: null\\n&quot;                    + &quot;&#125;&quot;);            out.flush();            out.close();            return;        &#125;        filterChain.doFilter(servletRequest, servletResponse);    &#125;    @Override    public void destroy() &#123;    &#125;&#125;\n\n\n\n\n面向管理员的如下，主要判断是否处于登录状态以及是否是管理员权限\npackage com.shu.mall.filter;import com.shu.mall.common.Constant;import com.shu.mall.model.pojo.User;import com.shu.mall.service.UserService;import org.springframework.beans.factory.annotation.Autowired;import javax.servlet.*;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import javax.servlet.http.HttpServletResponseWrapper;import javax.servlet.http.HttpSession;import java.io.IOException;import java.io.PrintWriter;//统一校验处理public class AdminFilter implements Filter &#123;    @Autowired    UserService userService;    @Override    public void init(FilterConfig filterConfig) throws ServletException &#123;    &#125;    @Override    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123;        HttpServletRequest request1 = (HttpServletRequest) request;        HttpSession session = request1.getSession();        User currentUser = (User) session.getAttribute(Constant.LIVE_MALL_USER);        if (currentUser == null) &#123;            PrintWriter out = new HttpServletResponseWrapper((HttpServletResponse) response).getWriter();            out.write(&quot;&#123;\\n&quot;                    + &quot;    \\&quot;status\\&quot;: 10007,\\n&quot;                    + &quot;    \\&quot;msg\\&quot;: \\&quot;NEED_LOGIN\\&quot;,\\n&quot;                    + &quot;    \\&quot;data\\&quot;: null\\n&quot;                    + &quot;&#125;&quot;);            out.flush();            out.close();            return;        &#125;        //校验当前登录用户是否管理员        if (currentUser.getRole() == 2) &#123;            chain.doFilter(request,response);        &#125; else &#123;            PrintWriter out = new HttpServletResponseWrapper((HttpServletResponse) response).getWriter();            out.write(&quot;&#123;\\n&quot;                    + &quot;    \\&quot;status\\&quot;: 10009,\\n&quot;                    + &quot;    \\&quot;msg\\&quot;: \\&quot;NEED_ADMIN\\&quot;,\\n&quot;                    + &quot;    \\&quot;data\\&quot;: null\\n&quot;                    + &quot;&#125;&quot;);            out.flush();            out.close();        &#125;    &#125;    @Override    public void destroy() &#123;    &#125;&#125;\n\n8、PageInfo分页处理\n首先，导入pagehelper依赖\n\n&lt;dependency&gt;          &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt;          &lt;artifactId&gt;pagehelper-spring-boot-starter&lt;/artifactId&gt;          &lt;version&gt;1.2.13&lt;/version&gt;      &lt;/dependency&gt;\n\n2. 然后初始化分页参数、查询结果、对查询结果进行分页\n\npackage com.shu.mall.service.impl;import com.github.pagehelper.PageHelper;import com.github.pagehelper.PageInfo; @Override    public PageInfo listforAdmin(Integer pageNum, Integer pageSize)&#123;        PageHelper.startPage(pageNum,pageSize);        List&lt;Product&gt; products = productMapper.selectListForAdmin();        PageInfo pageInfo = new PageInfo(products);        return pageInfo;\n\n\n面向用户的商品列表返回，涉及搜索处理、目录处理、排序处理。Query对象中默认设置pageNum=1，pageSize=10\n\n@Override    public PageInfo list(ProductListReq productListReq) &#123;        //构建Query对象        ProductListQuery productListQuery = new ProductListQuery();        //搜索处理        if (!StringUtils.isEmpty(productListReq.getKeyword())) &#123;            String keyword = new StringBuilder().append(&quot;%&quot;).append(productListReq.getKeyword())                    .append(&quot;%&quot;).toString();            productListQuery.setKeyword(keyword);        &#125;        //目录处理：如果查某个目录下的商品，不仅是需要查出该目录下的，还要把所有子目录的所有商品都查出来，所以要拿到一个目录id的List        if (productListReq.getCategoryId() != null) &#123;            List&lt;CategoryVo&gt; categoryVoList = categoryService                    .listCategoryForCustomer(productListReq.getCategoryId());            ArrayList&lt;Integer&gt; categoryIds = new ArrayList&lt;&gt;();            categoryIds.add(productListReq.getCategoryId());            getCategoryIds(categoryVoList, categoryIds);            productListQuery.setCategoryIds(categoryIds);        &#125;        //排序处理        String orderBy = productListReq.getOrderBy();        if (Constant.ProductListOrderBy.PRICE_ASC_DESC.contains(orderBy)) &#123;            PageHelper.startPage(productListReq.getPageNum(), productListReq.getPageSize(), orderBy);        &#125; else &#123;            PageHelper.startPage(productListReq.getPageNum(), productListReq.getPageSize());        &#125;        List&lt;Product&gt; productList = productMapper.selectList(productListQuery);        PageInfo pageInfo = new PageInfo(productList);        return pageInfo;    &#125;    private void getCategoryIds(List&lt;CategoryVo&gt; categoryVoList, ArrayList&lt;Integer&gt; categoryIds) &#123;        for (int i = 0; i &lt; categoryVoList.size(); i++) &#123;            CategoryVo categoryVo = categoryVoList.get(i);            if (categoryVo != null) &#123;                categoryIds.add(categoryVo.getId());                getCategoryIds(categoryVo.getChildCategory(), categoryIds);            &#125;        &#125;    &#125;\n\n9、事务管理订单模块\n触发回滚的异常设置为Exception.class，MySQL的默认事务隔离级别是可重复读\n\n@Transactional(rollbackFor = Exception.class)@Overridepublic String create(CreateOrderReq createOrderReq)&#123;    //拿到用户ID    Integer userId = UserFilter.currentUser.getId();    //从购物车查找已经勾选的商品    List&lt;CartVO&gt; cartVOList = cartService.list(userId);    ArrayList&lt;CartVO&gt; cartVOTemp = new ArrayList&lt;&gt;();    for (int i = 0; i &lt; cartVOList.size(); i++) &#123;        CartVO cartVO = cartVOList.get(i);        if (cartVO.getSelected().equals(Constant.Cart.CHECKED)) &#123;            cartVOTemp.add(cartVO);        &#125;    &#125;    cartVOList = cartVOTemp;    //如果购物车已勾选的为空，报错    if (CollectionUtils.isEmpty(cartVOList)) &#123;        throw new LiveMallException(LiveMallExceptionEnum.CART_EMPTY);    &#125;    //判断商品是否存在、上下架状态、库存    validSaleStatusAndStock(cartVOList);    //把购物车对象转化成订单item对象    List&lt;OrderItem&gt; orderItemList = cartVOListToOrderItemList(cartVOList);    //扣库存    for (int i = 0; i &lt; orderItemList.size(); i++) &#123;        Product product = productMapper.selectByPrimaryKey(orderItemList.get(i).getProductId());        Integer stock = product.getStock();        stock=stock-orderItemList.get(i).getQuantity();        if (stock&lt;0)&#123;            throw new LiveMallException(LiveMallExceptionEnum.NOT_ENOUGH);        &#125;        product.setStock(stock);        productMapper.updateByPrimaryKeySelective(product);    &#125;    //把购物车中的已勾选商品删除    cleanCart(cartVOList);    //生成订单    Order order = new Order();    //生成订单号，有独立的规则    String orderNo = OrderCodeFactory.getOrderCode(Long.valueOf(userId));    order.setOrderNo(orderNo);    order.setUserId(userId);    order.setTotalPrice(totalPrice(orderItemList));    order.setReceiverName(createOrderReq.getReceiverName());    order.setReceiverMobile(createOrderReq.getReceiverMobile());    order.setReceiverAddress(createOrderReq.getReceiverAddress());    order.setOrderStatus(Constant.OrderStatusEnum.NOT_PAID.getCode());    order.setPostage(0);    order.setPaymentType(1);    //插入到order表    orderMapper.insertSelective(order);    //循环保存每个商品到order_item表    for (int i = 0; i &lt; orderItemList.size(); i++) &#123;        OrderItem orderItem = orderItemList.get(i);        orderItem.setOrderNo(order.getOrderNo());        orderItemMapper.insertSelective(orderItem);    &#125;    //把结果返回    return orderNo;&#125;\n\n[TOC]\n","categories":[],"tags":[]},{"title":"鼓楼|歌词","url":"https://sacharn.github.io/2021/03/22/鼓楼-歌词/","content":"我走在鼓楼下面\n路在堵着\n雨后的阳光散落\n人们都出来了\n执着的迷惘的\n文艺青年很多\n如果我无聊了就会来这里坐坐\n我是个沉默不语的靠着墙壁晒太阳的过客\n如果我有些倦意了\n就让我在这里独自醒过\n我站在鼓楼上面\n一切繁华与我无关\n这是个拥挤的地方\n而我却很平凡\n我走在鼓楼下面\n淋湿的咖啡馆\n睡不着的后海边\n月亮还在抽着烟\n喝醉的亲吻着\n快活的人不眠\n唯有我倚着围栏\n对过往说晚安\n晚安\n我是个沉默不语的靠着车窗想念你的乘客\n当一零七路再次经过\n时间是带走青春的电车\n我站在什刹海边\n一切甜蜜与我无关\n这是个拥挤的地方\n而我却很孤单\n我在鼓楼 我在鼓楼\n我在鼓楼 我在鼓楼\n我在鼓楼 我在鼓楼\n","categories":[],"tags":[]},{"title":"JVM知识问答总结","url":"https://sacharn.github.io/2021/03/21/JVM知识问答总结/","content":"1. JVM基础1.1 对JVM的认识和理解\n功能：JVM的全称是Java虚拟机，用来运行字节码文件（.class）。\n优点：它屏蔽了具体操作系统和平台的差异，使得同一字节码能在不同平台运行，且能得到相同的结果。\n\n1.1.1 什么是字节码\n定义：扩展名为 .class 的的文件叫做字节码，相比较于源码，它是程序的一种低级表示。\n特性：不面向特定的处理器，只面向虚拟机JVM，经过虚拟机处理过后，程序可以在多平台上运行。\n\n1.1.2 Java 程序从代码到运行的过程\n过程：编写 -&gt; 编译 -&gt; 解释\n⾸先通过IDE/编辑器编写源代码然后经过 JDK 中的编译器（javac）编译成 Java 字节码⽂件（.class⽂件），字节码通过虚拟机执⾏，虚拟机将每⼀条要执⾏的字节码送给解释器，解释器会将其翻译成特定机器上的机器码（及其可执⾏的⼆进制机器码）。\n\n1.2 对类加载器的了解\n功能：类加载器根据指定class文件的全限定名称（例如java.lang.Object，路径+文件的形式），将其加载到JVM内存，转化为Class对象\n\n1.2.1 类加载器的执行流程\n1.2.1.1 加载\n通过类的全限定名来获取该类的二进制字节流\n将二进制字节流所代表的静态存储结构导入为方法区的运行时数据结构\n在堆中生成一个对象来代表这个类，作为方法区数据的入口\n\n1.2.1.2 链接\n验证：保证二进制字节流符合虚拟机的要求，且不会威胁到虚拟机的安全。\n\n准备：为static静态变量分配内存，并设置初始值。\n\n解析：虚拟机将常量池中的符号引用转化为直接引用。\n例如 import xxx.xxx.xxx 属于符号引⽤，⽽通过指针或者对象地址引⽤就是直接引⽤\n\n\n1.2.1.3 初始化​    初始化会对变量进⾏赋值，即对最初的零值，进⾏显式初始化\n1.2.1.4 卸载​    GC 垃圾回收内存中的⽆⽤对象\n1.2.2 类加载器有哪几种，加载顺序是什么样的\n启动类加载器：JDK目录/lib下的jar和类以及**-Xbootclasspath参数指定路径下**的所有类\n\n扩展类加载器：JRE⽬录/lib 下⾯的 jar 和类以及java.ext.dirs 系统变量所指定的路径下的 jar 包\n\n应用类加载器：当前应⽤下 classpath 下⾯的 jar 包和类\n顺序：最底层向上\n\n\n1.2.3 双亲委派机制\n⼯作过程是：如果⼀个类加载器收到了类加载的请求，他⾸先不会⾃⼰去尝试加载这个类，⽽是把这个请求委派给⽗类加载器去完成，每⼀个层次的类加载都是如此，因此所有的加载请求都最终应该传送到最顶层的启动类加载器中，只有当⽗加载器反馈⾃⼰⽆法完成这个加载请求（也就是它的范围搜索中，也没有找到所需要的类），⼦加载器才会尝试⾃⼰去完成加载。\n\n优点：\n\n加载位于rt.jar包中的类（例如 java.lang.Object）时不管是哪个加载器加载，最终都会委托最顶端的启动类加载器 BootStrapClassLoader 进⾏加载，这样保证它在各个类加载器环境下都是同⼀个结果。\n避免了⾃定义代码影响 JDK 的代码，如果我们⾃⼰也创建了⼀个 java.lang.Object 然后放在程序的 classpath 中，就会导致系统中出现不同的 Object 类，Java 类型体系中最基础的⾏为也就⽆法保证。\n\n\n不想用双亲委派机制怎么没办\n自定义类加载器，然后重写loadClass()方法\n\n\n","categories":[],"tags":[]},{"title":"MySQL是如何实现事务隔离的","url":"https://sacharn.github.io/2021/03/21/MySQL是如何实现事务隔离的/","content":"\n首先，读未提交和串行化都是比较极端的做法，读未提交压根不加锁，所以也没有什么隔离效果，可以理解为无隔离。\n其次，串行化。读的时候加共享锁，大家一起读。但是写的时候加排它锁，其他事务既不能并发写，也不能并发读。\n最后是读提交和可重复读。这两种隔离级别比较复杂，因为既要允许一定程度的并发，也要兼顾解决问题。\n\n实现可重复读为了解决不可重复读，或者为了实现可重复读，MySQL 采⽤了 MVVC (多版本并发控制) 的⽅式。\n！可重复读\n我们在数据库表中看到的⼀⾏记录可能实际上有多个版本，每个版本的记录除了有数据本⾝外，还要有⼀个表示版本的字段，记为 row trx_id，⽽这个字段就是使其产⽣的事务的 id，事务 ID 记为 transaction id，它在事务开始的时候向事务系统申请，按时间先后顺序递增。\n\n快照是可重复读和不可重复读的关键，可重复读是在事务开始的时候⽣成⼀个当前事务全局性的快照，⽽读提交则是每次执⾏语句的时候都重新⽣成⼀次快照。\n\n解决并发写问题\n假设事务A执⾏ update 操作， update 的时候要对所修改的行加行锁，这个⾏锁会在提交之后才释放。⽽在事务A提交之前，事务B也想 update 这⾏数据，于是申请⾏锁，但是由于已经被事务A占有，事务B是申请不到的，此时，事务B就会⼀直处于等待状态，直到事务A提交，事务B才能继续执⾏，如果事务A的时间太长，那么事务B很有可能出现超时异常。\n加锁的过程要分有索引和⽆索引两种情况，⽐如下⾯这条语句\n\nupdate user set age=11 where id = 1\n\n\nid 是这张表的主键，是有索引的情况，那么 MySQL 直接就在索引数中找到了这⾏数据，然后⼲净利落的直接加上⾏锁就可以了。\n\n⽽下⾯这条语句\nupdate user set age=11 where age=10\n\n\n表中并没有为 age 字段设置索引，所以， MySQL ⽆法直接定位到这⾏数据。那怎么办呢，当然也不是加表锁了。MySQL 会为这张表中所有⾏加⾏锁，没错，是所有⾏。但是呢，在加上⾏锁后，MySQL 会进⾏⼀遍过滤，发现不满⾜的⾏就释放锁，最终只留下符合条件的⾏。虽然最终只为符合条件的⾏加了锁，但是这⼀锁⼀释放的过程对性能也是影响极⼤的。所以，如果是⼤表的话，建议合理设计索引，如果真的出现这种情况，那很难保证并发度。\n\n解决幻读问题\nMySQL 已经在可重复读隔离级别下解决了幻读的问题。\n\n前⾯刚说了并发写问题的解决⽅式就是⾏锁，⽽解决幻读⽤的也是锁，叫做间隙锁，MySQL把⾏锁和间隙锁合并在⼀起，解决了并发写和幻读的问题，这个锁叫做 Next-Key锁。\n\n在行记录上加行锁，在行记录两边的区间加上间隙锁。\n！解决幻读问题的间隙锁\n\n\n在事务A提交之前，事务B的插⼊操作只能等待，这就是间隙锁起得作⽤。当事务A执⾏\nupdate user set name=&#x27;风筝2号’ where age = 10;\n\n 的时候，由于条件 here age = 10，数据库不仅在 age =10 的⾏上添加了⾏锁，⽽且在这条记录的两边，也就是(负⽆穷,10]、(10,30]这两个区间加了间隙锁，从⽽导致事务B插⼊操作⽆法完成，只能等待事务A提交。不仅插⼊ age = 10 的记录需要等待事务A提交，age&lt;10、10&lt;age&lt;30 的记录页⽆法完成，⽽⼤于等于30的记录则不受影响，这⾜以解决幻读问题了。这是有索引的情况，如果 age 不是索引列，那么数据库会为整个表加上间隙锁。所以，如果是没有索引的话，不管 age 是否⼤于等于30，都要等待事务A提交才可以成功插⼊。\n总结\nMySQL 的 InnoDB 引擎才⽀持事务，其中可重复读是默认的隔离级别。\n读未提交和串⾏化基本上是不需要考虑的隔离级别，前者不加锁限制，后者相当于单线程执⾏，效率太差。\n读提交解决了脏读问题，⾏锁解决了并发更新的问题。并且 MySQL 在可重复读级别解决了幻读问题，是通过⾏锁和间隙锁的组合 Next-Key 锁实现的。\n\n","categories":[],"tags":[]},{"title":"MySQL事务隔离级别原理","url":"https://sacharn.github.io/2021/03/20/MySQL事务隔离级别和实现原理/","content":"MySQL事务\nMySQL 事务都是指在 InnoDB 引擎下，因为MyISAM引擎是不支持事务的。\n数据库是指：一组数据操作，事务内的操作要么全部成功，要么全部失败。只要有一步失败，就要回滚所有操作。\n事务具有四个特性：ACID——原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）、持久性（Durability）\n\n四大问题：什么是脏读、可重复读、不可重复读、幻读？\n脏读：读到了其他事务修改了但尚未提交的数据。这个事务的操作有可能发生回滚，那么就可能发生错误。\n可重复读：在一个事务内，从事务开始到事务结束，期间读到的同一批数据，始终是一致的。通常，针对数据更新（UPDATE）操作。\n不可重复读：在一个事务内，不同时刻读到的数据可能是不一致的。通常，针对数据更新（UPDATE）操作。\n幻读：幻读是针对插入（INSERT）操作来说的。假设事务A对某些⾏的内容作了更改，但是还未提交，此时事务B插⼊了与事务A更改前的记录相同的记录⾏，并且在事务A提交之前先提交了，⽽这时，在事务A中查询，会发现好像刚刚的更改对于某些数据未起作⽤，但其实是事务B刚插⼊进来的，让⽤户感觉很魔幻，感觉出现了幻觉，这就叫幻读。\n\n四大隔离级别：读未提交、读提交、可重复读、串行化\nMySQL的默认隔离级别是可重复读。\n\nMySQL 中执⾏事务：事务的执⾏过程如下，以 begin 或者 start transaction 开始，然后执⾏⼀系列操作，最后要执⾏ commit 操作，事务才算结束。当然，如果进⾏回滚操作(rollback)，事务也会结束。\n需要注意的是，begin 命令并不代表事务的开始，事务开始于 begin 命令之后的第⼀条语句执⾏的时候。例如下⾯⽰例中，\nselect * from xxx \n\n才是事务的开始。\nbegin; select * from xxx;  commit; -- 或者 rollback;\n\n\n\n1、读未提交MySQL 事务隔离其实是依靠锁来实现的，加锁自然会带来性能的损失。⽽读未提交隔离级别是不加锁的，所以它的性能是最好的，没有加锁、解锁带来的性能开销。但有利就有弊，这基本上就相当于裸奔啊，所以它连脏读的问题都没办法解决。\n读未提交，其实就是可以读到其他事务未提交的数据，但没有办法保证你读到的数据最终⼀定是提交后的数据，如果中间发⽣回滚，那就会出现脏数据问题，读未提交没办法解决脏数据问题。更别提可重复读和幻读了。\n2、读提交为了解决脏数据问题，就有了读提交隔离级别。读提交就是⼀个事务只能读到其他事务已经提交过的数据，也就是其他事务调⽤ commit 命令之后的数据。那脏数据问题迎刃而解了。\n但这也导致了⼀个问题，在同⼀事务中（事务B），事务的不同时刻，同样的查询条件，查询出来的记录内容是不⼀样的。事务A的提交影响了事务B的查询结果（事务A提交前数值为1，提交后数值为10），这就是不可重复读问题，也就是读提交隔离级别。\n3、可重复读为了解决不可重复读问题，就有了可重复读隔离级别。同时启动两个事务A、B，事务A修改某数据并提交，但是事务B并不受修改的影响，读取的仍然是事务A修改前的值。\n但这仍然存在一个问题，对于新插⼊的⾏记录，就没这么幸运了，幻读就这么产⽣了。\n其实，MySQL 的可重复读隔离级别其实解决了幻读问题\n4、串行化为了解决幻读问题，就有了串行化的隔离级别。串⾏化是4种事务隔离级别中隔离效果最好的，解决了脏读、可重复读、幻读的问题，但是效果最差，它将事务的执⾏变为顺序执⾏，与其他三个隔离级别相⽐，它就相当于单线程，后⼀个事务的执⾏必须等待前⼀个事务结束。\n\n\n","categories":[],"tags":[]},{"title":"流水的学生，铁打的修路","url":"https://sacharn.github.io/2021/03/20/流水的学生，铁打的修路/","content":"​    坊间传闻着一句话——“半年修一次，一次修半年”，说的就是学校永不停歇的修路工程。\n","categories":[],"tags":[]},{"title":"Hello World","url":"https://sacharn.github.io/2021/03/18/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n","categories":[],"tags":[]}]